/**
  ****************************(C) COPYRIGHT 2019 DJI****************************
  * @file       chassis.c
  * @brief     	底盘控制任务
	*
	*     000000000000000     00               00    00     00   00         00 
	*           00     0      00                00    00   00     00       00  
	*       00  00000        00000000000000      00  000000000   00000000000000
	*       00  00          00           00    00    000000000     00     00   
	*      00000000000     00  000000    00     000     00           000000    
	*     00    00   0000     00    00   00      00   000000           00      
	*       00000000000       00    00   00           000000           00      
	*       0   00    0       0000000 00 00       00    00       00000000000000
	*       00000000000       00       000       00 00000000000        00      
	*           00            00                000 00000000000        00      
	*           00  00        00          0    000      00             00      
	*      000000000000        00        000  000       00          00 00      
	*       00        00        000000000000            00            00       
	********************************************************************************/
	
#include "arm_math.h"
#include "bsp_usart.h"
#include "CAN_receive.h"
#include "chassis_behaviour.h"
#include "chassis_calculate.h"
#include "chassis_power_control.h"
#include "chassis_task.h"
#include "cmsis_os.h"
#include "detect_task.h"
#include "INS_task.h"
#include "iwdg.h"
#include "pid.h"
#include "remote_control.h"
#include "slip_control.h"

#define rc_deadband_limit(input, output, dealine)	  \
{                                                		\
	if ((input) > (dealine) || (input) < -(dealine))	\
	{                                             		\
		(output) = (input);                          		\
	}                                             		\
	else                                          		\
	{                                             		\
		(output) = 0;                          					\
	}                                          				\
}

#if INCLUDE_uxTaskGetStackHighWaterMark
	uint32_t chassis_high_water;
#endif


/* 底盘运动数据 */
chassis_move_t chassis_move;


/**
  * @brief          底盘测量数据更新，包括3508电机速度、6020电机角度、欧拉角度、机器人速度
  * @param[out]     chassis_move_update:"chassis_move"变量指针.
  * @retval         none
  */
static void chassis_feedback_update(chassis_move_t *chassis_move_update)
{
	if (chassis_move_update == NULL) return;
	
	//定义两个变量用于记录车轮当前角度和速度
	fp32 wheel_angle[4], wheel_speed[4];
	
	for (uint8_t i = 0; i < 4; i++)
	{
		//更新3508电机速度和加速度，加速度是速度的PID微分
		chassis_move_update->chassis_3508[i].speed = chassis_move_update->chassis_3508[i].chassis_motor_measure->speed_rpm / MPS_to_RPM;
		wheel_speed[i] = chassis_move_update->chassis_3508[i].speed;
		chassis_move_update->chassis_3508[i].accel = chassis_move_update->chas_3508_pid[i].Dbuf[0] * CHASSIS_CONTROL_FREQUENCE;
		//更新6020电机角度
		chassis_move_update->chassis_6020[i].angle = rad_format(chassis_move_update->chassis_6020[i].chassis_motor_measure->ecd / GM6020_Angle_Ratio);
		wheel_angle[i] = chassis_move_update->chassis_6020[i].angle;
	}
	
	//底盘有陀螺仪
	chassis_move_update->chassis_yaw 	 = rad_format(*(chassis_move_update->chassis_INS_angle + INS_YAW_ADDRESS_OFFSET	 ));
	chassis_move_update->chassis_pitch = rad_format(*(chassis_move_update->chassis_INS_angle + INS_PITCH_ADDRESS_OFFSET));
	chassis_move_update->chassis_roll	 = rad_format(*(chassis_move_update->chassis_INS_angle + INS_ROLL_ADDRESS_OFFSET ));
		
	//用运动学逆解算更新底盘纵向速度 x, 平移速度 y, 旋转速度 wz, 坐标系为右手系(前x左y上z)
	chas_for_cal(wheel_angle, wheel_speed, &chassis_move_update->vx, &chassis_move_update->vy, &chassis_move_update->wz);
}

/**
  * @brief          初始化"chassis_move"变量，包括pid初始化, 遥控器指针初始化, 3508底盘电机指针初始化, 云台电机初始化, 陀螺仪角度指针初始化
  * @param[out]     chassis_move_init:"chassis_move"变量指针.
  * @retval         none
  */
static void chassis_init(chassis_move_t *chassis_move_init)
{
	if (chassis_move_init == NULL) return;

	//底盘3508速度环pid值
	const static fp32 chas_3508_pid_param[3] = {M3505_MOTOR_SPEED_PID_KP, M3505_MOTOR_SPEED_PID_KI, M3505_MOTOR_SPEED_PID_KD};
	//底盘6020角度环pid值
	const static fp32 chas_6020_pid_param[3] = {GM6020_MOTOR_ANGLE_PID_KP, GM6020_MOTOR_ANGLE_PID_KI, GM6020_MOTOR_ANGLE_PID_KD};
	//底盘角度pid值
	const static fp32 chassis_yaw_pid_param[3] = {CHASSIS_FOLLOW_GIMBAL_PID_KP, CHASSIS_FOLLOW_GIMBAL_PID_KI, CHASSIS_FOLLOW_GIMBAL_PID_KD};
	
	//底盘开机状态为原始
	chassis_move_init->chassis_mode = CHASSIS_VECTOR_RAW;
	//获取遥控器指针
	chassis_move_init->chassis_RC = get_remote_control_point();
	//获取陀螺仪姿态角指针
	chassis_move_init->chassis_INS_angle = get_INS_angle_point();
	//获取云台电机数据指针
	chassis_move_init->chassis_yaw_motor = get_yaw_motor_point();
	chassis_move_init->chassis_pitch_motor = get_pitch_motor_point();
	
	//获取底盘电机数据指针，初始化PID 
	for (uint8_t i = 0; i < 4; i++)
	{
		chassis_move_init->chassis_3508[i].chassis_motor_measure = get_chassis_motor_measure_point(i);
		PID_init(&chassis_move_init->chas_3508_pid[i], PID_USUAL, chas_3508_pid_param, M3505_MOTOR_SPEED_PID_MAX_OUT, M3505_MOTOR_SPEED_PID_MAX_IOUT);
		chassis_move_init->chassis_6020[i].chassis_motor_measure = get_chassis_motor_measure_point(i + 4);
		PID_init(&chassis_move_init->chas_6020_pid[i], PID_USUAL, chas_6020_pid_param, GM6020_MOTOR_ANGLE_PID_MAX_OUT, GM6020_MOTOR_ANGLE_PID_MAX_IOUT);
	}
	//初始化角度PID
	PID_init(&chassis_move_init->chassis_angle_pid, PID_USUAL, chassis_yaw_pid_param, CHASSIS_FOLLOW_GIMBAL_PID_MAX_OUT, CHASSIS_FOLLOW_GIMBAL_PID_MAX_IOUT);
	
	//用一阶滤波代替斜波函数生成
	const static fp32 chassis_x_order_filter = CHASSIS_ACCEL_X_NUM;
	const static fp32 chassis_y_order_filter = CHASSIS_ACCEL_Y_NUM;
	first_order_filter_init(&chassis_move_init->chassis_cmd_slow_set_vx, CHASSIS_CONTROL_TIME, &chassis_x_order_filter);
	first_order_filter_init(&chassis_move_init->chassis_cmd_slow_set_vy, CHASSIS_CONTROL_TIME, &chassis_y_order_filter);

	//最大 最小速度
	chassis_move_init->vx_max_speed =  NORMAL_MAX_CHASSIS_SPEED_X;
	chassis_move_init->vx_min_speed = -NORMAL_MAX_CHASSIS_SPEED_X;
	chassis_move_init->vy_max_speed =  NORMAL_MAX_CHASSIS_SPEED_Y;
	chassis_move_init->vy_min_speed = -NORMAL_MAX_CHASSIS_SPEED_Y;
	
	//更新一下数据
	chassis_feedback_update(chassis_move_init);
}

/**
  * @brief          用遥控器或键盘设置底盘控制模式
  * @param[out]     chassis_move_mode:"chassis_move"变量指针.
  * @retval         none
  */
static void chassis_set_mode(chassis_move_t *chassis_move_mode)
{
	if (chassis_move_mode == NULL) return;
	chassis_behaviour_mode_set(chassis_move_mode);	//in file "chassis_behaviour.c"
}

/**
  * @brief          底盘模式改变
  * @param[out]     chassis_move_transit:"chassis_move"变量指针.
  * @retval         none
  */
static void chassis_mode_change_control_transit(chassis_move_t *chassis_move_transit)
{
	if (chassis_move_transit == NULL) return;

	if (chassis_move_transit->last_chassis_mode == chassis_move_transit->chassis_mode) return;
	
	//切入跟随云台模式
	if ((chassis_move_transit->last_chassis_mode != CHASSIS_VECTOR_FOLLOW_GIMBAL_YAW) && chassis_move_transit->chassis_mode == CHASSIS_VECTOR_FOLLOW_GIMBAL_YAW)
	{
		chassis_move_transit->chassis_relative_angle_set = 0.0f;
	}
	//切入不跟随云台模式
	else if ((chassis_move_transit->last_chassis_mode != CHASSIS_VECTOR_NO_FOLLOW_YAW) && chassis_move_transit->chassis_mode == CHASSIS_VECTOR_NO_FOLLOW_YAW)
	{
		chassis_move_transit->chassis_yaw_set = chassis_move_transit->chassis_yaw;
	}
	
	chassis_move_transit->last_chassis_mode = chassis_move_transit->chassis_mode;
}

/**
  * @brief          根据遥控器通道值，计算纵向和横移速度
  * @param[out]     vx_set: 纵向速度指针
  * @param[out]     vy_set: 横向速度指针
  * @param[out]     chassis_move_rc_to_vector: "chassis_move" 变量指针
  * @retval         none
  */
void chassis_rc_to_control_vector(fp32 *vx_set, fp32 *vy_set, chassis_move_t *chassis_move_rc_to_vector)
{
	if (chassis_move_rc_to_vector == NULL || vx_set == NULL || vy_set == NULL) return;
	
	int16_t vx_channel, vy_channel;
	fp32 vx_set_channel, vy_set_channel;
	
	//死区限制，因为遥控器可能存在差异 摇杆在中间，其值不为0
	rc_deadband_limit(chassis_move_rc_to_vector->chassis_RC->rc.ch[CHASSIS_X_CHANNEL], vx_channel, CHASSIS_RC_DEADLINE);
	rc_deadband_limit(chassis_move_rc_to_vector->chassis_RC->rc.ch[CHASSIS_Y_CHANNEL], vy_channel, CHASSIS_RC_DEADLINE);
	vx_set_channel = vx_channel * ( CHASSIS_VX_RC_SEN);
	vy_set_channel = vy_channel * (-CHASSIS_VY_RC_SEN);
	
	//键盘控制
	if (chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_FRONT_KEY)
	{
		vx_set_channel = chassis_move_rc_to_vector->vx_max_speed;
	}
	else if (chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_BACK_KEY)
	{
		vx_set_channel = chassis_move_rc_to_vector->vx_min_speed;
	}
	
	if (chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_LEFT_KEY)
	{
		vy_set_channel = chassis_move_rc_to_vector->vy_max_speed;
	}
	else if (chassis_move_rc_to_vector->chassis_RC->key.v & CHASSIS_RIGHT_KEY)
	{
		vy_set_channel = chassis_move_rc_to_vector->vy_min_speed;
	}

	//一阶低通滤波代替斜波作为底盘速度输入
	first_order_filter_cali(&chassis_move_rc_to_vector->chassis_cmd_slow_set_vx, vx_set_channel);
	first_order_filter_cali(&chassis_move_rc_to_vector->chassis_cmd_slow_set_vy, vy_set_channel);
	
	//遥感死区限制
	if (vx_set_channel < CHASSIS_RC_DEADLINE * CHASSIS_VX_RC_SEN && vx_set_channel > -CHASSIS_RC_DEADLINE * CHASSIS_VX_RC_SEN)
	{
		chassis_move_rc_to_vector->chassis_cmd_slow_set_vx.out = 0.0f;
	}
	if (vy_set_channel < CHASSIS_RC_DEADLINE * CHASSIS_VY_RC_SEN && vy_set_channel > -CHASSIS_RC_DEADLINE * CHASSIS_VY_RC_SEN)
	{
		chassis_move_rc_to_vector->chassis_cmd_slow_set_vy.out = 0.0f;
	}
	
	*vx_set = chassis_move_rc_to_vector->chassis_cmd_slow_set_vx.out;
	*vy_set = chassis_move_rc_to_vector->chassis_cmd_slow_set_vy.out;	
}

/**
  * @brief          设置底盘控制设置值, 三运动控制值是通过 chassis_behaviour_control_set 函数设置的
  * @param[out]     chassis_move_update:"chassis_move"变量指针.
  * @retval         none
  */
static void chassis_set_contorl(chassis_move_t *chassis_move_control)
{
	if (chassis_move_control == NULL) return;

	fp32 vx_set = 0.0f, vy_set = 0.0f, wz_set = 0.0f;

	//获取三个控制设置值
	chassis_behaviour_control_set(&vx_set, &vy_set, &wz_set, chassis_move_control);
	wz_set = - wz_set;
	//跟随云台模式
	if (chassis_move_control->chassis_mode == CHASSIS_VECTOR_FOLLOW_GIMBAL_YAW)
	{
		//计算旋转PID角速度
		chassis_move_control->wz_set = -PID_calc(&chassis_move_control->chassis_angle_pid, chassis_move_control->chassis_yaw_motor->relative_angle, chassis_move_control->chassis_relative_angle_set);
		//速度限幅
		chassis_move_control->vx_set = fp32_constrain(chassis_move_control->vx_set, chassis_move_control->vx_min_speed, chassis_move_control->vx_max_speed);
		chassis_move_control->vy_set = fp32_constrain(chassis_move_control->vy_set, chassis_move_control->vy_min_speed, chassis_move_control->vy_max_speed);
	}
	//底盘旋转
	else if (chassis_move_control->chassis_mode == CHASSIS_VECTOR_NO_FOLLOW_YAW)
	{
		//“wz_set”是旋转速度设置
		chassis_move_control->wz_set = wz_set;
		//速度限幅
		chassis_move_control->vx_set = fp32_constrain(vx_set, chassis_move_control->vx_min_speed, chassis_move_control->vx_max_speed);
		chassis_move_control->vy_set = fp32_constrain(vy_set, chassis_move_control->vy_min_speed, chassis_move_control->vy_max_speed);
	}
	//在原始模式，设置值是发送到CAN总线
	else if (chassis_move_control->chassis_mode == CHASSIS_VECTOR_RAW)
	{
		chassis_move_control->vx_set = vx_set;
		chassis_move_control->vy_set = vy_set;
		chassis_move_control->wz_set = wz_set;
		chassis_move_control->chassis_cmd_slow_set_vx.out = 0.0f;
		chassis_move_control->chassis_cmd_slow_set_vy.out = 0.0f;
	}
}

/**
  * @brief          控制循环，根据控制设定值，计算电机电流值，进行控制
  * @param[out]     chassis_move_control_loop:"chassis_move"变量指针.
  * @retval         none
  */
static void chassis_control_loop(chassis_move_t *chassis_move_control_loop)
{
	fp32 wheel_speed[4] = {0.0f, 0.0f, 0.0f, 0.0f};
	fp32 wheel_angle[4] = {0.0f, 0.0f, 0.0f, 0.0f};
	
	//底盘舵轮运动学逆解算
	chas_inv_cal(chassis_move_control_loop->vx_set,
	             chassis_move_control_loop->vy_set,
	             chassis_move_control_loop->wz_set,
							 wheel_angle, wheel_speed);
	
	//将算出的舵轮目标角度和目标速度赋值给angle_set、speed_set
	for(uint8_t i = 0; i < 4; i ++)
	{
		chassis_move_control_loop->chassis_6020[i].angle_set = wheel_angle[i];
		chassis_move_control_loop->chassis_3508[i].speed_set = wheel_speed[i];
	}
	
	//raw控制直接返回，但控制舵轮角度的电流需要用PID计算
	if (chassis_move_control_loop->chassis_mode == CHASSIS_VECTOR_RAW)
	{
		for(uint8_t i = 0; i < 4; i++)
		{
			chassis_move_control_loop->chassis_3508[i].give_current = (int16_t)(wheel_speed[i] * MPS_to_RPM * RPM_to_Icmd);
			PID_calc(&chassis_move_control_loop->chas_6020_pid[i], chassis_move_control_loop->chassis_6020[i].angle, wheel_angle[i]);
			chassis_move_control_loop->chassis_6020[i].give_current = (int16_t)(chassis_move_control_loop->chas_6020_pid[i].out);
		}
		return;
	}
	
	//打滑抑制
	slip_control(chassis_move_control_loop);

	for(uint8_t i = 0; i < 4; i++)
	{
		//计算pid
		PID_calc(&chassis_move_control_loop->chas_3508_pid[i], chassis_move_control_loop->chassis_3508[i].speed, chassis_move_control_loop->chassis_3508[i].speed_set);
		PID_calc(&chassis_move_control_loop->chas_6020_pid[i], chassis_move_control_loop->chassis_6020[i].angle, chassis_move_control_loop->chassis_6020[i].angle_set);
	}
	
	//功率控制(在 chassis_power_control() 函数中给舵轮3508和6020电机赋值电流值)
	chassis_power_control(chassis_move_control_loop);
}

/**
  * @brief          底盘任务，间隔 CHASSIS_CONTROL_TIME_MS 2ms
  * @param[in]      pvParameters: 空
  * @retval         none
  */
void chassis_task(void const *pvParameters)
{
	//HAL_IWDG_Refresh(&hiwdg);
	vTaskDelay(CHASSIS_TASK_INIT_TIME);	//空闲一段时间
	//HAL_IWDG_Refresh(&hiwdg);
	chassis_init(&chassis_move); //底盘初始化
	
	//判断底盘电机是否都在线
	while (toe_is_error(CHASSIS_MOTOR1_TOE) || toe_is_error(CHASSIS_MOTOR2_TOE) || toe_is_error(CHASSIS_MOTOR3_TOE) || toe_is_error(CHASSIS_MOTOR4_TOE) || \
				 toe_is_error(CHASSIS_MOTOR5_TOE) || toe_is_error(CHASSIS_MOTOR6_TOE) || toe_is_error(CHASSIS_MOTOR7_TOE) || toe_is_error(CHASSIS_MOTOR8_TOE) || \
				 toe_is_error(DBUS_TOE))
	{ vTaskDelay(CHASSIS_CONTROL_TIME_MS); }
	
	while (1)
	{
		//设置底盘控制模式
		chassis_set_mode(&chassis_move);
		//模式切换数据保存
		chassis_mode_change_control_transit(&chassis_move);
		//底盘数据更新
		chassis_feedback_update(&chassis_move);
		//底盘控制量设置
		chassis_set_contorl(&chassis_move);
		//底盘控制PID计算
		chassis_control_loop(&chassis_move);

		//确保至少一个电机在线， 这样CAN控制包可以被接收到
		if (!(toe_is_error(CHASSIS_MOTOR1_TOE) && toe_is_error(CHASSIS_MOTOR2_TOE) && toe_is_error(CHASSIS_MOTOR3_TOE) && toe_is_error(CHASSIS_MOTOR4_TOE) && \
					toe_is_error(CHASSIS_MOTOR5_TOE) && toe_is_error(CHASSIS_MOTOR6_TOE) && toe_is_error(CHASSIS_MOTOR7_TOE) && toe_is_error(CHASSIS_MOTOR8_TOE)))
		{
			//当遥控器掉线的时候，发送给底盘电机零电流.
			if (toe_is_error(DBUS_TOE))
			{
				CAN_cmd_CHAS_6020(0, 0, 0, 0);
				CAN_cmd_CHAS_3508(0, 0, 0, 0);
			}
			else
			{						
				//发送控制电流
				CAN_cmd_CHAS_6020(chassis_move.chassis_6020[0].give_current, chassis_move.chassis_6020[1].give_current,
													chassis_move.chassis_6020[2].give_current, chassis_move.chassis_6020[3].give_current);
				CAN_cmd_CHAS_3508(chassis_move.chassis_3508[0].give_current, chassis_move.chassis_3508[1].give_current,
													chassis_move.chassis_3508[2].give_current, chassis_move.chassis_3508[3].give_current);
				HAL_IWDG_Refresh(&hiwdg);
			}
		}
		//系统延时
		vTaskDelay(CHASSIS_CONTROL_TIME_MS);

		#if INCLUDE_uxTaskGetStackHighWaterMark
			chassis_high_water = uxTaskGetStackHighWaterMark(NULL);
		#endif
	}
}
